[
  
  {
    "title": "Simple water ripple (without RenderTexture and Particle System)",
    "url": "/posts/RipplesWithoutRenderTexture/",
    "categories": "unity",
    "tags": "unity, ripples",
    "date": "2022-03-20 17:30:00 +0800",
    





    "snippet": "  The generation of simple water ripples only needs the center position information, and the rest of the artistic effects can be achieved in the shader.  Since the shader cannot temporarily store the information, the script needs to pass the character position information to the shader.  (Can the geometry shader store information?)    Method    Custom FunctionCustom Function code reference	ScriptCode reference    Reference effect    ExtendsSparkling ShadergraphSparkling reference effectMethod      Store character positions in an array at intervals Vector4 waterRipples[]        Store individual water ripple lifetimes in waterRipples.w    (Time preferably needs to take into account whether the character moves, jumps, etc.)        Pass waterRipples to Shader        Calculate all water ripples in the shader  Custom Fuction：      A single water ripple code is as follows:    float RipplesTransform(float time, float3 positionWS, float4 center, float radius = 3, float speed = 0.5, float noise = 0){    float dist = distance((center.xyz + float3(0, 0.5, 0)), (positionWS + noise) * float3(1, 1, 2));    float changingRadius = center.w;    changingRadius = 1 - changingRadius;    changingRadius = 1 - pow(changingRadius,3);    float opacity = sin(changingRadius * 3.1415926);      float rings = abs(frac(dist - (time * speed)) - 0.5) * 2.0;    rings  = pow(rings,4);    float mask = RemapFloat01(dist, float2(0, radius * changingRadius));    mask = 1.0 - mask;    mask *= opacity;      return rings * mask;}            dist is the distance to the center point, where float3(0, .5, 0) is the height offset of the center point, used to adjust the height of the center position of the water ripple.    float3(1, 1, 2) is It is used to scale the distance in the z direction, so that an elliptical water ripple is obtained (if the character is not on the plane with the z axis of 0, it cannot be used directly)        RemapFloat01() maps a range to 01 (custom)        changingRadius is a value from 0 to 1 that controls the radius change and transparency.    The change of radius needs to be fast and then slow (blue curve), and the change of transparency also needs to be fast, then slow and finally disappear (orange curve).            rings is to loop through frac() and abs().        void SetWaterRipples() is used to perform calculations and output results to shadergraph.    void SetWaterRipple_float(    float3 posWS, float time, float noise, out float WaterRipples){    for (int i = 0; i &amp;lt; _ripplesParticlesSize; i++)    {        WaterRipples = lerp(RipplesTransform(time, posWS, _waterRipples[i], 7, 0.36, noise), 1, WaterRipples);    }}      The Custom Function reference code is as follows://-----Unity ShaderGraph Custom Function-----uniform float4 _waterRipples[10];uniform int _ripplesParticlesSize;float RemapFloat01(float In, float2 InMinMax){    return clamp((In - InMinMax.x) / (InMinMax.y - InMinMax.x), 0, 1);}//generate according to center posfloat RipplesTransform(float time, float3 positionWS, float4 center, float radius = 3, float speed = 0.5, float noise = 0){    float dist = distance((center.xyz + float3(0, 0.5, 0)), (positionWS + noise * .7) * float3(1, 1, 2));    float changingRadius = center.w;    changingRadius = 1 - changingRadius;    changingRadius = 1 - pow(changingRadius,3);    float opacity = sin(changingRadius * 3.1415926);    float rings = abs(frac(dist - (time * speed)) - 0.5) * 2.0;    rings  = pow(rings,4);    float mask = RemapFloat01(dist, float2(0, radius * changingRadius));    mask = 1.0 - mask;    mask *= opacity;    return rings * mask;}void SetWaterRipple_float( float3 posWS, float time, float noise,                    out float WaterRipples){    for (int i = 0; i &amp;lt; _ripplesParticlesSize; i++)    {        WaterRipples = lerp(RipplesTransform(time, posWS, _waterRipples[i], 7, 0.36, noise), 1, WaterRipples);    }}Script：      ripplesParticlesSize and waterRipples[] need to be passed to the shader. Where waterRipples[].xyz represents the center position of the water ripple, and waterRipples[].w represents the survival time of the water ripple;        waterRipples[].w can be affected by time_dissolving and time_jumping, time_jumping is determined by time_grounded and time_air.    In this way, the value of waterRipples[].w can be roughly used to represent the different states of the character when moving, when taking off, when in the air and when landing.  reference code://-----C# Script-----public class SetWaterRipples : MonoBehaviour{    private static int ripplesParticlesSize = 9;    private int count;    private Vector4[] waterRipples = new Vector4[ripplesParticlesSize];    private bool[] startSpreading = new bool[ripplesParticlesSize];    private float[] time_ripple = new float[ripplesParticlesSize];    [SerializeField] private float interval = .2f;    private float duration;    private float time;    private float time_dissolving;    private Transform playerTr;    private Vector3 playerPos;    private CharacterMovement _characterMovement;    private Controller _controller;    void Start()    {        playerTr = GameObject.FindWithTag(&quot;Player&quot;).transform;        _characterMovement = playerTr.gameObject.GetComponent&amp;lt;CharacterMovement&amp;gt;();        _controller = playerTr.gameObject.GetComponent&amp;lt;Controller&amp;gt;();                duration = (ripplesParticlesSize) * interval;        Shader.SetGlobalInt(&quot;_ripplesParticlesSize&quot;, ripplesParticlesSize);                for (int i = 0; i &amp;lt; ripplesParticlesSize; i++)        {            startSpreading[i] = false;        }    }        void Update()    {        playerPos = playerTr.position;        Timer();        if (time &amp;gt;= interval)        {            waterRipples[count] = playerPos + new Vector3(Random.Range(-.3f, .3f), 0f, Random.Range(-1f, 1f));            startSpreading[count] = true;                        count++;            if (count &amp;gt; ripplesParticlesSize-1)            {                count = 0;            }            time = 0f;        }        Shader.SetGlobalVectorArray(&quot;_waterRipples&quot;, waterRipples);    }    private bool isGrounded = false;    private float time_grounded;    private float time_air;    private float time_jumping;    void Timer()    {        time += Time.deltaTime;        for (int i = 0; i &amp;lt; ripplesParticlesSize; i++)        {            if (startSpreading[i])            {                time_ripple[i] += Time.deltaTime;              	//combination of ripple appreance                waterRipples[i].w = Mathf.Clamp01(Mathf.InverseLerp(0f, duration, time_ripple[i])) * Mathf.Lerp(time_dissolving, 1f,                    (1f - time_jump) * Mathf.Sin(Mathf.PI * (1f - Mathf.Pow((1f - time_jump), 3f)) ));                if (time_ripple[i] &amp;gt;= duration)                {                    startSpreading[i] = false;                    time_ripple[i] = 0f;                }            }        }                //appear when jumping        isGrounded = _controller.State.IsGrounded;        if (isGrounded)        {            time_air = 0f;                        time_grounded += Time.deltaTime * .6f;            if (time_grounded &amp;gt;= 1f)            {                time_grounded = 1f;            }        }        else        {            time_grounded = 0f;            time_air += Time.deltaTime * 1f;            if (time_air &amp;gt;= 1f)            {                time_air = 1f;            }        }        time_jumping = Mathf.Lerp(time_grounded, 1f, time_air);                //appear when moving        if (_characterMovement._horizontalMovement != 0f)        {            time_dissolving += Time.deltaTime * 1f;            if (time_dissolving &amp;gt;= 1f)            {                time_dissolving = 1f;            }        }        else        {            time_dissolving -= Time.deltaTime * 0.3f;            if (time_dissolving &amp;lt;= 0f)            {                time_dissolving = 0f;            }        }    }}Extends  Add sparkling effect to water surfaceThe effect is more noticeable at a distance.This can be done using positionWS.z combined with Screen Position to add noise at the end(Below is the reference of screen space near and far)Demo:Final Shadergraph："
  },
  
  {
    "title": "2D crowd animation using ShaderGraph",
    "url": "/posts/Shader%E5%AE%9E%E7%8E%B02D%E4%BA%BA%E7%BE%A4%E5%8A%A8%E7%94%BB/",
    "categories": "unity, shadergraph",
    "tags": "unity, 2D animation, shadergraph, custom function",
    "date": "2022-03-20 17:30:00 +0800",
    





    "snippet": "  Through uv combined with animation and other methods to achieve crowds with different states, such as different heights, different colors, different animation playback speeds, different crowd space gaps, etc., and the linerenderer can be used to plan the path.Limitations: the best effect on the plane, and can not have too much tilt angle    Implementationuv.x settingInterval setupsprite sheet setup	Extends  Using a sequence of frame animation drawn before for demonstration.IMPLEMENTATION:  The key is to use the value of the world coordinate x as the uv.x value.The rest of the effects roughly expand from here.      Set the x-axis of the world coordinate as uv.x, and keep uv.y unchanged for the time being. This allows you to change the width at will without affecting the number of columns.    Because uv.y is unchanged, you can use linerenderer to do the effect of uphill and downhill.        After taking the modulo of the uv.x obtained in the previous step, it can be used as a transparent channel to represent the interval (remember to take the absolute value)            Adding sequence animation requires modifications to uv.y. This method recommends that the number of rows of the sprite sheet be 1 (if the number of rows is not 1, the interval should be a multiple of 2). Sequence frame animation can be obtained by simple calculations such as modulo.  EXTENDS:Use the integer part of the u obtained in the implementation  method 1  to make random, and then use lerp to randomize the various values in the shader, thereby simulating the randomness of the crowd (or objects).Because uv.x is rounded and then random, it can ensure that each column is assigned a random value.E.g:      Random height scaling can be done before uv.y does various calculations (the degree of scaling depends on how much space is above each frame in the sprite sheet)        Sprite sheets can use this to add an offset to make the playback order and speed different.        The interval and color can also be random        Each instance can also be offset and randomized based on world position. Object position can be used, but not when using linerenderer, because its object position is the origin of world coordinates (0, 0, 0).    When using the linerenderer, you can directly use the z of the world position for offset or randomization, provided that these objects are in the same direction as the z-axis (sometimes there may be flickering, especially when the camera changes focus or z-direction displacement occurs. Solution: floor or ceil(a*positionWS.z) )        The advantage of using linerenderer is that the path can be edited, and the operation is convenient, but it is not very convenient to deal with randomness.    You can make a simple model according to your needs and use vertex color to do the position offset. This allows for simple up and down slopes, and even a little offset from the z-axis has a good effect.        The final integrated shadergraph:  "
  }
  
]

